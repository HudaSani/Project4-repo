# -*- coding: utf-8 -*-
"""Project4(Nuclei Detection).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HJiaQbAYpPjfRmOs36c-cmz_YdboKuYe
"""

#upload data into google colab by mounting drive
from google.colab import drive
drive.mount('/content/drive')

# install tensorflow_examples.model.pix2pix
# use for transfer learning
!pip install git+https://github.com/tensorflow/examples.git

import tensorflow as tf
import tensorflow_datasets as tfds
from tensorflow_examples.models.pix2pix import pix2pix
from IPython.display import clear_output
import matplotlib.pyplot as plt
import numpy as np
import cv2
import glob
from scipy import io
import os

#1. Data loading
#1.1 Set directories

train_file_directory = '/content/drive/MyDrive/data-science-bowl-2018-2/train'
test_file_directory = '/content/drive/MyDrive/data-science-bowl-2018-2/test'

#1.2 Load the images
# prepare a list for image and mask
# file from the directories is fetch randomly causing the inputs and masks are not belong to each other
# the files are put into a list and being sorted to match the inputs with the masks

def load_image(file_path):

  def first_5chars(x):
    return(x[:5]) 

  images=[]

  image_list = os.listdir(file_path)

  for image_file in sorted(image_list, key = first_5chars):
    print(image_file)
    img = cv2.imread(os.path.join(file_path,image_file),cv2.IMREAD_COLOR)
    img = cv2.resize(img,(128,128))
    images.append(img)
  return images

train_image_dir = os.path.join(train_file_directory,'inputs')
train_image = load_image(train_image_dir)

test_image_dir = os.path.join(test_file_directory,'inputs')
test_image = load_image(test_image_dir)

#1.3 Load the mask
# same process as in 1.2 done to the masks files

def load_mask(file_path):
  
  def first_5chars(x):
    return(x[:5])

  masks=[]

  masks_list = os.listdir(file_path)

  for mask_file in sorted(masks_list, key = first_5chars):
    print(mask_file)
    mask = cv2.imread(os.path.join(file_path,mask_file),cv2.IMREAD_GRAYSCALE)
    mask = cv2.resize(mask,(128,128))
    masks.append(mask)
  return masks

train_mask_dir = os.path.join(train_file_directory,'masks')
train_mask = load_mask(train_mask_dir)

test_mask_dir = os.path.join(test_file_directory,'masks')
test_mask = load_mask(test_mask_dir)

#1.4 Convert images and masks into numpy array
train_images_np = np.array(train_image)
test_images_np = np.array(test_image)
train_masks_np = np.array(train_mask)
test_masks_np = np.array(test_mask)

#1.5 Check some examples
plt.figure(figsize=(10,4))
for i in range(1,4):
  plt.subplot(1,3,i)
  img_plot = train_image[i]
  plt.imshow(img_plot)
  plt.axis('off')

plt.figure(figsize=(10,4))
for i in range(1,4):
  plt.subplot(1,3,i)
  mask_plot = train_mask[i]
  plt.imshow(mask_plot, cmap='gray')
  plt.axis('off')

plt.show()

# the inputs image and masks are match

#2. Data preprocessing

#2.1. Expand the mask dimension

train_masks_np_exp = np.expand_dims(train_masks_np,axis=-1)
test_masks_np_exp = np.expand_dims(test_masks_np,axis=-1)

#Check the mask output
print(train_mask[0].min(),train_mask[0].max())

#2.2 Change the mask value (1. normalize the value, 2. encode the numerical encoding)
train_converted_masks = np.round(train_masks_np_exp/225)
train_converted_masks = 1 - train_converted_masks
test_converted_masks = np.round(test_masks_np_exp/225)
test_converted_masks = 1 - test_converted_masks

#2.3 Normalize the images
train_converted_images = train_images_np/225.0
test_converted_images = test_images_np/225.0

#2.4 Do train-test split
from sklearn.model_selection import train_test_split

SEED = 12345
x_train, x_test,y_train,y_test = train_test_split(train_converted_images,train_converted_masks,test_size=0.2,random_state=SEED)

#2.5 Convert the numpy array data into tensor slices
train_x = tf.data.Dataset.from_tensor_slices(x_train)
val_x = tf.data.Dataset.from_tensor_slices(x_test)
train_y = tf.data.Dataset.from_tensor_slices(y_train)
val_y = tf.data.Dataset.from_tensor_slices(y_test)
test_x = tf.data.Dataset.from_tensor_slices(test_converted_images)
test_y = tf.data.Dataset.from_tensor_slices(test_converted_masks)

#2.6 Zip tensor slice into dataset
train = tf.data.Dataset.zip((train_x,train_y))
val = tf.data.Dataset.zip((val_x,val_y))
test = tf.data.Dataset.zip((test_x,test_y))

#2.7 Convert into prefetch dataset
BATCH_SIZE = 20
AUTOTUNE = tf.data.AUTOTUNE
BUFFER_SIZE = 1000
STEPS_PER_EPOCH = 800//BATCH_SIZE
VALIDATION_STEP = 200//BATCH_SIZE

train = train.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()
train = train.prefetch(buffer_size=AUTOTUNE)
val = val.batch(BATCH_SIZE).repeat()
val = val.prefetch(buffer_size=AUTOTUNE)
test = test.batch(BATCH_SIZE).prefetch(buffer_size=AUTOTUNE)

#3. Prepare model
#create a modified version of U-Net
base_model = tf.keras.applications.MobileNetV2(input_shape=[128,128,3], include_top=False)

layer_names = [
    'block_1_expand_relu',   # 64x64
    'block_3_expand_relu',   # 32x32
    'block_6_expand_relu',   # 16x16
    'block_13_expand_relu',  # 8x8
    'block_16_project',      # 4x4
]

base_model_outputs = [base_model.get_layer(name).output for name in layer_names]

# Create the feature extraction model
down_stack = tf.keras.Model(inputs=base_model.input, outputs=base_model_outputs)

down_stack.trainable = False

#
up_stack = [
    pix2pix.upsample(512, 3),  # 4x4 -> 8x8
    pix2pix.upsample(256, 3),  # 8x8 -> 16x16
    pix2pix.upsample(128, 3),  # 16x16 -> 32x32
    pix2pix.upsample(64, 3),   # 32x32 -> 64x64
]

#function to create the entire model
def unet_model(output_channels:int):
  inputs = tf.keras.layers.Input(shape=[128, 128, 3])

  # Downsampling through the model
  skips = down_stack(inputs)
  x = skips[-1]
  skips = reversed(skips[:-1])

  # Upsampling and establishing the skip connections
  for up, skip in zip(up_stack, skips):
    x = up(x)
    concat = tf.keras.layers.Concatenate()
    x = concat([x, skip])

  # This is the last layer of the model
  last = tf.keras.layers.Conv2DTranspose(
      filters=output_channels, kernel_size=3, strides=2,
      padding='same')  #64x64 -> 128x128

  x = last(x)

  return tf.keras.Model(inputs=inputs, outputs=x)

#Define the model
OUTPUT_CLASSES = 2
model = unet_model(output_channels=OUTPUT_CLASSES)

# Compile the model and display the model structure
model.compile(optimizer='adam', loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])
model.summary()
tf.keras.utils.plot_model(model, show_shapes=True, show_layer_names=True, show_layer_activations=True)

#Create a function to display some examples
def display(display_list):
    plt.figure(figsize=(15,15))
    title = ['Input Image','True Mask', 'Predicted Mask']
    
    for i in range(len(display_list)):
        plt.subplot(1, len(display_list),i+1)
        plt.title(title[i])
        plt.imshow(tf.keras.preprocessing.image.array_to_img(display_list[i]))
        plt.axis('off')
        
    plt.show()
    
for images, masks in train.take(2):
    sample_image, sample_mask = images[0], masks[0]
    display([sample_image,sample_mask])

#Create a function to process predicted mask
def create_mask(pred_mask):
    pred_mask = tf.argmax(pred_mask,axis=-1)
    pred_mask = pred_mask[..., tf.newaxis]
    return pred_mask

#Create a function to display prediction
def show_predictions(dataset=None,num=1):
    if dataset:
        for image, mask in dataset.take(num):
            pred_mask = model.predict(image)
            display([image[0],mask[0],create_mask(pred_mask)[0]])
    else:
        display([sample_image,sample_mask,create_mask(model.predict(sample_image[tf.newaxis,...]))[0]])

#Custom callback to display result during training
class DisplayCallback(tf.keras.callbacks.Callback):
    def on_epoch_end(self, epoch, logs=None):
        clear_output(wait=True)
        show_predictions()
        print('\n Sample prediction after epoch {}\n'.format(epoch+1))

#Tensorflow callback
import datetime
log_dir = "logs/fit/" + datetime.datetime.now().strftime("%y%m%d-%H%M%S")
tb_callback=tf.keras.callbacks.TensorBoard(log_dir)
es_callback = tf.keras.callbacks.EarlyStopping(monitor='val_loss',patience=3,verbose=2)

#Start to do the training
EPOCH = 50
history = model.fit(train,epochs=EPOCH,
                    steps_per_epoch=STEPS_PER_EPOCH, 
                    validation_steps=VALIDATION_STEP,
                    validation_data=val,
                    callbacks=[DisplayCallback(),tb_callback, es_callback])

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
# %tensorboard --logdir logs

#Test evaluation
test_loss, test_accuracy = model.evaluate(test)
print(f"Test loss = {test_loss}")
print(f"Test accuracy = {test_accuracy}")

#Deploy model by using the show_prediction functions created before
show_predictions(test,3)